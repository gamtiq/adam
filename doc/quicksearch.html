<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"adam.js.html":{"id":"adam.js.html","title":"Source: adam.js","body":" adam Modules adam Source: adam.js /* * adam * https://github.com/gamtiq/adam * * Copyright (c) 2014-2020 Denis Sikuler * Licensed under the MIT license. */ /** * Functions to create, process and test objects. * * @module adam */ \"use strict\"; /*jshint latedef:nofunc*/ var getOwnPropertyNames, getPropertySymbols, getPrototypeOf; /*jshint laxbreak:true*/ /* * Return own property names of given object. * * @param {Object} obj * Object whose own property names should be returned. * @return {Array} * Own property names of the given object. */ getOwnPropertyNames = typeof Object.getOwnPropertyNames === \"function\" ? Object.getOwnPropertyNames : function getOwnPropertyNames(obj) { var result = [], sKey; for (sKey in obj) { result.push(sKey); } return result; }; /* * Return prototype of given object. * * @param {Object} obj * Object whose prototype should be returned. * @return {Object} * The prototype of the given object. */ getPrototypeOf = typeof Object.getPrototypeOf === \"function\" ? Object.getPrototypeOf : function getPrototypeOf(obj) { /*jshint proto:true*/ return obj ? (obj.constructor ? obj.constructor.prototype : (obj.__proto__ || Object.prototype) ) : null; }; /*jshint laxbreak:false*/ if (typeof Object.getOwnPropertySymbols === \"function\") { /** * Return list of all symbol property keys for given object including keys from prototype chain. * * This function is defined only when `Object.getOwnPropertySymbols` is available. * * @param {Object} obj * Object to be processed. * @return {Array} * List of all found symbol property keys. * @alias module:adam.getPropertySymbols */ getPropertySymbols = function getPropertySymbols(obj) { var exceptList = {}, getOwnPropertySymbols = Object.getOwnPropertySymbols, getPrototypeOf = Object.getPrototypeOf, result = [], nI, nL, propName, symbolList; if (obj &amp;&amp; typeof obj === \"object\") { do { symbolList = getOwnPropertySymbols(obj); for (nI = 0, nL = symbolList.length; nI &lt; nL; nI++) { propName = symbolList[nI]; if (! (propName in exceptList)) { result.push(propName); exceptList[propName] = true; } } obj = getPrototypeOf(obj); } while (obj); } return result; }; } /** * Return class of given value (namely value of internal property `[[Class]]`). * * @param {Any} value * Value whose class should be determined. * @return {String} * String indicating value class. * @alias module:adam.getClass */ function getClass(value) { var sClass = Object.prototype.toString.call(value); return sClass.substring(8, sClass.length - 1); } /** * Return type of given value. * * @param {Any} value * Value whose type should be determined. * @return {String} * For `NaN` - `'nan'`, for `null` - `'null'`, otherwise - result of `typeof` operator. * @alias module:adam.getType */ function getType(value) { /*jshint laxbreak:true*/ var sType = typeof value; return value === null ? \"null\" : (sType === \"number\" &amp;&amp; isNaN(value) ? \"nan\" : sType); } /** * Return number of all or filtered fields of specified object. * * @param {Object} obj * Object to be processed. * @param {Object} [settings] * Operation settings. Keys are settings names, values are corresponding settings values. * The following settings are supported: * * * `filter` - a filter specifying fields that should be counted (see {@link module:adam.checkField checkField}) * * `filterConnect`: `String` - a boolean connector that should be used when array of filters is specified * in `filter` setting (see {@link module:adam.checkField checkField}) * @return {Integer} * Number of all or filtered fields of specified object. * @alias module:adam.getSize * @see {@link module:adam.getFields getFields} */ function getSize(obj, settings) { return getFields(obj, settings).length; } /** * Check whether number of all or filtered fields of specified object is more than the given value. * * @param {Object} obj * Object to be checked. * @param {Number} nValue * Value that should be used for comparison with number of fields. * @param {Object} [settings] * Operation settings. Keys are settings names, values are corresponding settings values. * The following settings are supported: * * * `filter` - a filter specifying fields that should be counted (see {@link module:adam.checkField checkField}) * * `filterConnect`: `String` - a boolean connector that should be used when array of filters is specified * in `filter` setting (see {@link module:adam.checkField checkField}) * @return {Boolean} * `true`, when number of all or filtered fields is more than the given value, otherwise `false`. * @alias module:adam.isSizeMore * @see {@link module:adam.getFields getFields} */ function isSizeMore(obj, nValue, settings) { /*jshint unused:false*/ if (settings) { settings = copy(settings, {}); } else { settings = {}; } nValue++; settings.limit = nValue; return getFields(obj, settings).length === nValue; } /** * Check whether given value is an empty value i.e. `null`, `undefined`, `0`, empty object, empty array or empty string. * * @param {Any} value * Value to be checked. * @return {Boolean} * `true` if the value is an empty value, otherwise `false`. * @alias module:adam.isEmpty * @see {@link module:adam.getClass getClass} * @see {@link module:adam.isSizeMore isSizeMore} */ function isEmpty(value) { /*jshint eqeqeq:false, eqnull:true, laxbreak:true*/ return value == null || value === 0 || value === \"\" || (typeof value === \"object\" &amp;&amp; ! isSizeMore(value, 0)) || (getClass(value) === \"Array\" &amp;&amp; value.length === 0); } /** * Check whether given value has (or does not have) specified kind (type or class). * * @param {Any} value * Value to be checked. * @param {String} sKind * Type or class for check. Can be any value that is returned by {@link module:adam.getType getType} * and {@link module:adam.getClass getClass}, or one of the following: * * * `empty` - check whether the value is empty (see {@link module:adam.isEmpty isEmpty}) * * `even` - check whether the value is an even integer * * `false` - check whether the value is a false value * * `infinity` - check whether the value is a number representing positive or negative infinity * * `integer` - check whether the value is an integer number * * `negative` - check whether the value is a negative number * * `numeric` - check whether the value is a number or a string that can be converted to number * * `odd` - check whether the value is an odd integer * * `positive` - check whether the value is a positive number * * `real` - check whether the value is a real number * * `true` - check whether the value is a true value * * `zero` - check whether the value is `0` * * If exclamation mark (`!`) is set before the kind, it means that the check should be negated * i.e. check whether given value does not have the specified kind. * For example, `!real` means: check whether the value is not a real number. * @return {Boolean} * `true` if value has the specified kind (or does not have when the check is negated), otherwise `false`. * @alias module:adam.isKindOf * @see {@link module:adam.getClass getClass} * @see {@link module:adam.getType getType} * @see {@link module:adam.isEmpty isEmpty} */ function isKindOf(value, sKind) { /*jshint laxbreak:true*/ var bNegate = sKind.charAt(0) === \"!\", sType = getType(value), bInfinity, bInteger, bResult; if (bNegate) { sKind = sKind.substring(1); } bResult= sType === sKind || getClass(value) === sKind || (sKind === \"true\" &amp;&amp; Boolean(value)) || (sKind === \"false\" &amp;&amp; ! value) || (sKind === \"empty\" &amp;&amp; isEmpty(value)) || (sKind === \"numeric\" &amp;&amp; ( sType === \"number\" || (sType === \"string\" &amp;&amp; value &amp;&amp; ! isNaN(Number(value))) ) ) || (sType === \"number\" &amp;&amp; ((sKind === \"zero\" &amp;&amp; value === 0) || (sKind === \"positive\" &amp;&amp; value &gt; 0) || (sKind === \"negative\" &amp;&amp; value &lt; 0) || ((bInfinity = (value === Number.POSITIVE_INFINITY || value === Number.NEGATIVE_INFINITY)) &amp;&amp; (sKind === \"infinity\")) || (! bInfinity &amp;&amp; ( ((bInteger = (value === Math.ceil(value))) &amp;&amp; sKind === \"integer\") || (bInteger &amp;&amp; sKind === \"even\" &amp;&amp; value % 2 === 0) || (bInteger &amp;&amp; sKind === \"odd\" &amp;&amp; value % 2 !== 0) || (! bInteger &amp;&amp; sKind === \"real\") ) ) ) ); return bNegate ? ! bResult : bResult; } /** * Check whether the field of given object corresponds to specified condition(s) or filter(s). * * @param {Object} obj * Object to be processed. * @param {String | Symbol} field * Field that should be checked. * @param {Any} filter * A filter or array of filters specifying conditions that should be checked. A filter can be: * * * a function; if the function returns a true value it means that the field corresponds to this filter; * the following parameters will be passed into the function: field value, field name and reference to the object * * a regular expression; if the field value (converted to string) matches the regular expression it means * that the field corresponds to this filter * * a string; value can be one of the following: * - `own` - if the field is own property of the object it means that the field corresponds to this filter * - `!own` - if the field is not own property of the object it means that the field corresponds to this filter * - any other value - is used as the check when calling {@link module:adam.isKindOf isKindOf}; * if {@link module:adam.isKindOf isKindOf} returns `true` for the given field value and the filter * it means that the field corresponds to this filter * * an object; * - if the object has `and` or `or` field, its value is used as subfilter and will be passed in recursive call of `checkField` * as value of `filter` parameter; the field name (`and` or `or`) will be used as value of `filterConnect` setting (see below); * if the result of the recursive call is `true` it means that the field corresponds to this filter * - if the object has `field` field, its value is used as filter for the field name (property key) that is being checked; * the filter is applied to the field name (property key) in recursive call of `checkField` * as if the key is a tested field value of special object that is created for the check purposes * (i.e. `checkField({field: field}, \"field\", filter.field, {filterConnect: settings.filterConnect})`) * - if the object has `value` field, its value is used as filter; if the field value strictly equals to the filter value * it means that the field corresponds to this filter * - in any other case if the field value strictly equals to the object it means that the field corresponds to this filter * * any other value; if the field value strictly equals to the filter value it means that the field corresponds to this filter * @param {Object} [settings] * Operation settings. Keys are settings names, values are corresponding settings values. * The following settings are supported (setting's default value is specified in parentheses): * * * `filterConnect`: `String` (`and`) - a boolean connector that should be used when array of filters is specified * in `filter` parameter; valid values are the following: `and`, `or` (case-insensitive); any other value is treated as `and` * * `value`: `Any` - a value that should be used for check instead of field's value * @return {Boolean} * `true` if the field corresponds to specified filter(s), otherwise `false`. * @alias module:adam.checkField * @see {@link module:adam.getClass getClass} * @see {@link module:adam.isKindOf isKindOf} */ function checkField(obj, field, filter, settings) { /*jshint laxbreak:true*/ var test = true, bAnd, nI, nL, value; if (! settings) { settings = {}; } value = \"value\" in settings ? settings.value : obj[field]; bAnd = settings.filterConnect; bAnd = typeof bAnd !== \"string\" || bAnd.toLowerCase() !== \"or\"; if (getClass(filter) !== \"Array\") { filter = [filter]; } for (nI = 0, nL = filter.length; nI &lt; nL; nI++) { test = filter[nI]; switch (getClass(test)) { case \"Function\": test = Boolean(test(value, field, obj)); break; case \"String\": if (test === \"own\") { test = obj.hasOwnProperty(field); } else if (test === \"!own\") { test = ! obj.hasOwnProperty(field); } else { test = isKindOf(value, test); } break; case \"RegExp\": test = test.test(typeof value === \"symbol\" ? value.toString() : value); break; case \"Object\": if (\"and\" in test) { test = checkField(obj, field, test.and, {filterConnect: \"and\"}); } else if (\"or\" in test) { test = checkField(obj, field, test.or, {filterConnect: \"or\"}); } else if (\"field\" in test) { test = checkField({field: field}, \"field\", test.field, {filterConnect: settings.filterConnect}); } else if (\"value\" in test) { test = test.value === value; } else { test = test === value; } break; default: test = test === value; } if ((bAnd &amp;&amp; ! test) || (! bAnd &amp;&amp; test)) { break; } } return test; } /** * Return list of all or filtered fields of specified object. * * Fields are searched (checked) in the object itself and in its prototype chain. * * @param {Object} obj * Object to be processed. * @param {Object} [settings] * Operation settings. Keys are settings names, values are corresponding settings values. * The following settings are supported: * * * `filter` - a filter specifying fields that should be selected (see {@link module:adam.checkField checkField}) * * `filterConnect`: `String` - a boolean connector that should be used when array of filters is specified * in `filter` setting (see {@link module:adam.checkField checkField}) * * `limit` - a maximum number of fields that should be included into result; * after the specified number of fields is attained, the search will be stopped * @return {Array} * List of all or filtered fields of specified object. * @alias module:adam.getFields * @see {@link module:adam.checkField checkField} */ function getFields(obj, settings) { /*jshint latedef:false, laxbreak:true*/ function isLimitReached() { return nLimit &gt; 0 &amp;&amp; result.length &gt;= nLimit; } function processKeyList(keyList) { var key, nI, nL; for (nI = 0, nL = keyList.length; nI &lt; nL; nI++) { key = keyList[nI]; if ((bAll || checkField(obj, key, filter, settings)) &amp;&amp; ! (key in addedKeyMap)) { result.push(key); if (isLimitReached()) { break; } addedKeyMap[key] = null; } } } var addedKeyMap = {}, bAll = ! settings || ! (\"filter\" in settings), getOwnPropertySymbols = Object.getOwnPropertySymbols, bProcessSymbols = typeof getOwnPropertySymbols === \"function\", filter = bAll ? null : settings.filter, bOwn = bAll ? false : filter === \"own\", bNotOwn = bAll ? false : filter === \"!own\", bUseFilter = bAll ? false : ! bOwn &amp;&amp; ! bNotOwn, nLimit = (settings &amp;&amp; settings.limit) || 0, result = [], target = obj; while (target) { if (bAll || bUseFilter || (bOwn &amp;&amp; target === obj) || (bNotOwn &amp;&amp; target !== obj)) { processKeyList(getOwnPropertyNames(target)); if (bProcessSymbols &amp;&amp; ! isLimitReached()) { processKeyList(getOwnPropertySymbols(target)); } if (isLimitReached()) { break; } } target = bAll || bNotOwn || bUseFilter ? getPrototypeOf(target) : null; } return result; } /** * Return the name of field (or list of names) having the specified value in the given object. * * @param {Object} obj * Object to be checked. * @param {Any} value * Value that should be searched for. * @param {Boolean} [bAll] * Whether names of all found fields having the specified value should be returned. * Default value is `false`. * @return {Array | String | null} * Names of fields (when `bAll` is `true`) or a field name having the specified value, * or `null` when the object do not contain the specified value. * @alias module:adam.getValueKey */ function getValueKey(obj, value, bAll) { /*jshint laxbreak:true*/ var result = [], sKey; for (sKey in obj) { if (obj[sKey] === value) { if (bAll) { result.push(sKey); } else { return sKey; } } } return result.length ? result : null; } /** * Return list of all or filtered field values of specified object. * * @param {Object} obj * Object to be processed. * @param {Object} [settings] * Operation settings. Keys are settings names, values are corresponding settings values. * The following settings are supported: * * * `filter` - a filter specifying fields that should be selected (see {@link module:adam.checkField checkField}) * * `filterConnect`: `String` - a boolean connector that should be used when array of filters is specified * in `filter` setting (see {@link module:adam.checkField checkField}) * @return {Array} * List of all or filtered field values of specified object. * @alias module:adam.getValues * @see {@link module:adam.checkField checkField} */ function getValues(obj, settings) { var result = [], bAll = ! settings || ! (\"filter\" in settings), filter = bAll ? null : settings.filter, sKey; for (sKey in obj) { if (bAll || checkField(obj, sKey, filter, settings)) { result[result.length] = obj[sKey]; } } return result; } /** * Return name of first free (absent) field of specified object, that conforms to the following pattern: * &amp;lt;prefix&amp;gt;&amp;lt;number&amp;gt; * * @param {Object} obj * Object in which a free field should be found. * If `null` (or any false value) is set, the first value that conforms to the pattern will be returned. * @param {Object} [settings] * Operation settings. Keys are settings names, values are corresponding settings values. * The following settings are supported (setting's default value is specified in parentheses): * * * `checkPrefix`: `Boolean` (`false`) - specifies whether pattern consisting only from prefix (without number) should be checked * * `prefix`: `String` (`f`) - prefix of sought field * * `startNum`: `Integer` (`0`) - starting number which is used as part of pattern by search/check * @return {String} * Name of field which is absent in the specified object and conforms to the pattern. * @alias module:adam.getFreeField */ function getFreeField(obj, settings) { var bCheckPrefix, nStartNum, sField, sPrefix; if (! settings) { settings = {}; } sPrefix = settings.prefix; nStartNum = settings.startNum; bCheckPrefix = settings.checkPrefix; if (typeof sPrefix !== \"string\") { sPrefix = \"f\"; } if (! nStartNum) { nStartNum = 0; } if (bCheckPrefix) { sField = sPrefix; nStartNum--; } else { sField = sPrefix + nStartNum; } if (obj) { while (sField in obj) { sField = sPrefix + (++nStartNum); } } return sField; } /** * Create object (map) from list of objects. * Fields of the created object are values of specified field of objects, * values of the created object are corresponding items of the list. * * @param {Array} list * List of objects/values to be processed. * @param {Function | String} [keyField] * Specifies names of fields of the created object. Can be name of field or method whose value is used * as field name of the created object, or function that returns the field name. * In the latter case the following parameters will be passed in the function: * the source object (an item of the list), the created object, the index of the source object. * When the parameter is not set, items of the list are used as field names. * @param {Object} [settings] * Operation settings. Keys are settings names, values are corresponding settings values. * The following settings are supported (setting's default value is specified in parentheses): * * * `deleteKeyField`: `Boolean` (`false`) - specifies whether key field (whose value is field name of the created object) * should be deleted from the source object (an item of the list) * * `filter` - a filter specifying objects that should be included into result (see {@link module:adam.checkField checkField}); * an item of the list will be used as value for check * * `filterConnect`: `String` - a boolean connector that should be used when array of filters is specified * in `filter` setting (see {@link module:adam.checkField checkField}) * @return {Object} * Object created from the given list. * @alias module:adam.fromArray * @see {@link module:adam.checkField checkField} */ function fromArray(list, keyField, settings) { var nL = list.length, result = {}, bAll, bDeleteKeyField, bFuncKey, filter, filterConnect, item, field, nI, sKeyName; if (nL) { if (! settings) { settings = {}; } bAll = ! (\"filter\" in settings); filter = bAll ? null : settings.filter; filterConnect = settings.filterConnect; bFuncKey = typeof keyField === \"function\"; bDeleteKeyField = Boolean(settings.deleteKeyField &amp;&amp; keyField); if (! bFuncKey) { sKeyName = keyField; } for (nI = 0; nI &lt; nL; nI++) { item = list[nI]; if (bFuncKey) { field = sKeyName = keyField(item, result, nI); } else { field = sKeyName ? item[sKeyName] : item; if (typeof field === \"function\") { field = field.call(item); } } if (bAll || checkField(result, field, filter, {value: item, filterConnect: filterConnect})) { if (bDeleteKeyField) { delete item[sKeyName]; } result[field] = item; } } } return result; } /** * Return the value of the first element in the passed array that satisfies the specified filter(s). * * If value passed for selection is not an array, the value will be returned as is. * If no element in the passed array satisfies the specified filter(s), * `settings.defaultValue` or the last element of the array (or `undefined` when the array is empty) will be returned. * * @param {Any} filter * Filter that should be used to select a value (see {@link module:adam.checkField checkField} for details). * @param {Any} from * An array from which a value should be selected. * If passed value is not an array, the value will be returned as is. * @param {Object} [settings] * Operation settings. Keys are settings names, values are corresponding settings values. * The following settings are supported (setting's default value is specified in parentheses): * * * `defaultValue`: `Any` - default value that should be used when no element in the passed array * satisfies the specified filter(s) * * `filterConnect`: `String` (`and`) - a boolean connector that should be used when array of filters is specified * in `filter` parameter (see {@link module:adam.checkField checkField} for details) * @return {Any} * The first element in the passed array that satisfies the specified filter(s), * or `settings.defaultValue` or the last element of the array when no element in the array satisfies the specified filter(s), * or `settings.defaultValue` or `undefined` when the array is empty, * or the value of `from` parameter when passed value is not an array. * @alias module:adam.select * @see {@link module:adam.checkField checkField} */ function select(filter, from, settings) { /*jshint laxbreak:true*/ var result = from, options = settings || {}, nI, nL, nLast; if (getClass(from) === \"Array\") { nL = from.length; if (nL) { nLast = nL - 1; for (nI = 0; nI &lt; nL; nI++) { if (checkField(from, nI, filter, options)) { result = from[nI]; break; } else if (nI === nLast) { result = \"defaultValue\" in options ? options.defaultValue : from[nI]; } } } else { result = \"defaultValue\" in options ? options.defaultValue : nI; } } return result; } /** * Divide given object into 2 parts: the first part includes specified fields, the second part includes all other fields. * * @param {Object} obj * Object to be divided. * @param {Array | Object | null} firstObjFields * List of names of fields that should be included in the first part, * or an object defining those fields. * If value is not specified (`null` or `undefined`), `filter` setting should be used to divide fields into parts. * @param {Object} [settings] * Operation settings. Keys are settings names, values are corresponding settings values. * The following settings are supported: * * * `filter` - a filter that should be used to divide fields into parts (see {@link module:adam.checkField checkField}); * fields conforming to the filter will be included in the first part, * fields that do not conform to the filter will be included in the second part * * `filterConnect`: `String` - a boolean connector that should be used when array of filters is specified * in `filter` setting (see {@link module:adam.checkField checkField}) * @return {Array} * Created parts: item with index 0 is the first part, item with index 1 is the second part. * @alias module:adam.split * @see {@link module:adam.checkField checkField} */ function split(obj, firstObjFields, settings) { /*jshint laxbreak:true*/ var first = {}, second = {}, result = [first, second], bByName, filter, sKey; if (! settings) { settings = {}; } if (firstObjFields) { bByName = true; if (typeof firstObjFields.length === \"number\") { firstObjFields = fromArray(firstObjFields); } } else { bByName = false; filter = settings.filter; } for (sKey in obj) { ((bByName ? sKey in firstObjFields : checkField(obj, sKey, filter, settings)) ? first : second)[sKey] = obj[sKey]; } return result; } /** * Remove filtered fields/elements from specified object/array. * * @param {Array | Object} obj * Array or object to be processed. * @param {Any} filter * A filter or array of filters specifying fields or elements that should be removed * (see {@link module:adam.checkField checkField}). * @param {Object} [settings] * Operation settings. Keys are settings names, values are corresponding settings values. * The following settings are supported: * * * `filterConnect`: `String` - a boolean connector that should be used when array of filters is specified * in `filter` parameter (see {@link module:adam.checkField checkField}) * @return {Array | Object} * Processed array or object. * @alias module:adam.remove * @see {@link module:adam.checkField checkField} */ function remove(obj, filter, settings) { var field; if (obj &amp;&amp; typeof obj === \"object\") { if (getClass(obj) === \"Array\") { field = obj.length; while(field--) { if (checkField(obj, field, filter, settings)) { obj.splice(field, 1); } } } else { for (field in obj) { if (checkField(obj, field, filter, settings)) { delete obj[field]; } } } } return obj; } /** * Empty the given value according to the following rules: * * * for array: removes all elements from the value * * for object: removes all own fields from the value * * for string: returns empty string * * for number: returns `0` * * otherwise: returns `undefined` * * @param {Any} value * Value to be processed. * @return {Any} * Processed value (for array or object) or empty value corresponding to the given value. * @alias module:adam.empty */ function empty(value) { var sField; switch (getType(value)) { case \"object\": if (getClass(value) === \"Array\") { value.length = 0; } else { for (sField in value) { delete value[sField]; } } break; case \"string\": value = \"\"; break; case \"number\": value = 0; break; default: value = sField; } return value; } /** * Reverse or negate the given value according to the following rules: * * * for array: reverses order of its elements * * for object: swaps fields with their values (i.e. for `{a: \"b\", c: \"d\"}` returns `{b: \"a\", d: \"c\"}`) * * for string: reverses order of its characters * * for number: returns negated value (i.e. `- value`) * * for boolean: returns negated value (i.e. `! value`) * * otherwise: returns source value without modification * * @param {Any} value * Value to be processed. * @return {Any} * Processed value. * @alias module:adam.reverse */ function reverse(value) { var cache, sField; switch (getType(value)) { case \"object\": if (getClass(value) === \"Array\") { value = value.reverse(); } else { cache = {}; for (sField in value) { cache[ value[sField] ] = sField; } value = cache; } break; case \"string\": value = value.split(\"\").reverse().join(\"\"); break; case \"number\": value = - value; break; case \"boolean\": value = ! value; break; } return value; } /** * Transform the given value applying the specified operation. * * @param {Any} value * Value to be transformed. * @param {String} sAction * Operation that should be applied to transform the value. Can be one of the following: * * * `array` - convert the value to array (using `Array(value)`) * * `boolean` - convert the value to boolean value (using `Boolean(value)`) * * `empty` - empty the value (see {@link module:adam.empty empty}) * * `function` - convert the value to function (using `Function(value)`) * * `integer` - try to convert the value to an integer number (using `Math.round(Number(value)`) * * `number` - try to convert the value to number (using `Number(value)`) * * `object` - convert the value to object (using `Object(value)`) * * `reverse` - reverse the value (see {@link module:adam.reverse reverse}) * * `string` - convert the value to string (using `String(value)`) * * otherwise - source value * @return {Any} * Transformed value. * @alias module:adam.transform * @see {@link module:adam.empty empty} * @see {@link module:adam.reverse reverse} */ function transform(value, sAction) { /*jshint evil:true, -W064*/ var result; switch (sAction) { case \"array\": result = Array(value); break; case \"boolean\": result = Boolean(value); break; case \"empty\": result = empty(value); break; case \"function\": result = Function(value); break; case \"integer\": result = Math.round(Number(value)); break; case \"number\": result = Number(value); break; case \"object\": result = Object(value); break; case \"reverse\": result = reverse(value); break; case \"string\": result = String(value); break; default: result = value; } return result; } /** * Copy all or filtered fields from source object into target object, applying specified transformation if necessary. * * @param {Object} source * Object whose fields will be copied. * @param {Object} target * Object into which fields should be copied. * @param {Object} [settings] * Operation settings. Keys are settings names, values are corresponding settings values. * The following settings are supported: * * * `filter` - a filter that should be used to select fields for copying (see {@link module:adam.checkField checkField}); * fields conforming to the filter will be copied * * `filterConnect`: `String` - a boolean connector that should be used when array of filters is specified * in `filter` setting (see {@link module:adam.checkField checkField}) * * `transform` - an action/operation that should be applied to get field's value that will be copied * instead of value from source object; can be a string specifying transformation (see {@link module:adam.transform transform}) * or a function whose result will be used as field's value; object with the following fields will be passed into the function: * - `field` - field name * - `value` field value from source object * - `source` - reference to the source object * - `target` - reference to the target object * @return {Object} * Reference to the target object (value of `target` parameter). * @alias module:adam.copy * @see {@link module:adam.checkField checkField} * @see {@link module:adam.transform transform} */ function copy(source, target, settings) { /*jshint laxbreak:true*/ var bAll = true, bFuncAction, action, filter, key; if (! settings) { settings = {}; } if (\"filter\" in settings) { filter = settings.filter; bAll = false; } action = settings.transform; if (typeof action === \"function\") { bFuncAction = true; } for (key in source) { if (bAll || checkField(source, key, filter, settings)) { target[key] = action ? (bFuncAction ? action({source: source, target: target, field: key, value: source[key]}) : transform(source[key], action)) : source[key]; } } return target; } /** * Change all or filtered fields of object, applying specified action/transformation. * * @param {Object} obj * Object whose fields should be changed. * @param {Function | String} action * An action/operation that should be applied to get new field value. * See description of `transform` setting of {@link module:adam.copy copy}. * @param {Object} [settings] * Operation settings. Keys are settings names, values are corresponding settings values. * The following settings are supported: * * * `filter` - a filter that should be used to select fields for modification (see {@link module:adam.checkField checkField}); * fields conforming to the filter will be changed * * `filterConnect`: `String` - a boolean connector that should be used when array of filters is specified * in `filter` setting (see {@link module:adam.checkField checkField}) * @return {Object} * Modified object (value of `obj` parameter). * @alias module:adam.change * @see {@link module:adam.checkField checkField} * @see {@link module:adam.copy copy} */ function change(obj, action, settings) { /*jshint laxbreak:true*/ settings = settings ? copy(settings, {}) : {}; settings.transform = action; return copy(obj, obj, settings); } /** * Create new object containing all or filtered fields of the source object/array, * applying specified action/transformation for field values. * * @param {Array | Object} obj * Array/object whose fields should be copied. * @param {Function | String} action * An action/operation that should be applied to get field value that will be saved in created object. * See description of `transform` setting of {@link module:adam.copy copy}. * @param {Object} [settings] * Operation settings. Keys are settings names, values are corresponding settings values. * The following settings are supported: * * * `filter` - a filter that should be used to select fields for copying (see {@link module:adam.checkField checkField}); * fields conforming to the filter will be copied in created object * * `filterConnect`: `String` - a boolean connector that should be used when array of filters is specified * in `filter` setting (see {@link module:adam.checkField checkField}) * @return {Object} * Created object containing processed fields. * @alias module:adam.map * @see {@link module:adam.checkField checkField} * @see {@link module:adam.copy copy} */ function map(obj, action, settings) { /*jshint laxbreak:true*/ settings = settings ? copy(settings, {}) : {}; settings.transform = action; return copy(obj, getClass(obj) === \"Array\" ? [] : {}, settings); } // Exports module.exports = { change: change, checkField: checkField, copy: copy, empty: empty, fromArray: fromArray, getClass: getClass, getFields: getFields, getFreeField: getFreeField, getPropertySymbols: getPropertySymbols, getSize: getSize, getType: getType, getValueKey: getValueKey, getValues: getValues, isEmpty: isEmpty, isKindOf: isKindOf, isSizeMore: isSizeMore, map: map, remove: remove, reverse: reverse, select: select, split: split, transform: transform }; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" adam Modules adam Modules × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" adam Modules adam adam Functions to create, process and test objects. Usage Examples API Related projects InstallationNodenpm install adamBowerbower install adamAMD, &lt;script&gt;Use dist/adam.js or dist/adam.min.js (minified version). Usage ↑Nodevar adam = require(\"adam\");AMDdefine([\"path/to/dist/adam.js\"], function(adam) { ... });Bower, &lt;script&gt; &lt;!-- Use bower_components/adam/dist/adam.js if the library was installed by Bower --&gt; &lt;script type=\"text/javascript\" src=\"path/to/dist/adam.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; // adam is available via adam field of window object ... &lt;/script&gt;Examples ↑function inc(data) { return ++data.value; } var obj = {a: 1, b: 2, c: 3, d: 4, e: 5}, s1 = Symbol(\"s1\"), s2 = Symbol(\"s2\"), proto = {a: 1}, obj2 = Object.create(proto); proto[s1] = \"s1\"; obj2.b = 2; obj2[s2] = null; obj2.c = \"str\"; obj2.d = 0; adam.getPropertySymbols(obj2); // [s2, s1] adam.getClass([8]); // \"Array\" adam.getType(null); // \"null\" adam.isKindOf(17, \"integer\"); // true adam.isKindOf(NaN, \"!number\"); // true adam.isKindOf(\".321e+2\", \"numeric\"); // true adam.checkField(obj, \"c\", [\"positive\", \"odd\"]); // true adam.checkField(obj, \"b\", [\"real\", /^7/], {filterConnect: \"or\"}); // false adam.getFreeField({a5: 5, a2: 2, a7: 7, a3: 3}, {prefix: \"a\", startNum: 2}); // \"a4\" adam.getSize(obj); // 5 adam.getSize(obj, {filter: \"even\"}); // 2 adam.getSize(obj2, {filter: [\"string\", \"null\"], filterConnect: \"or\"}); // 3 adam.isSizeMore(obj, 5); // false adam.isSizeMore(obj2, 1, {filter: \"string\"}); // true adam.isEmpty({}); // true adam.getFields(obj); // [\"a\", \"b\", \"c\", \"d\", \"e\"] adam.getFields(obj, {filter: function(value) {return value &lt; 4;}}); // [\"a\", \"b\", \"c\"] adam.getFields(obj, {filter: {field: /^[d-h]/}}); // [\"d\", \"e\"] adam.getFields(obj2); // [\"b\", \"c\", \"d\", s2, \"a\", s1] adam.getFields(obj2, {filter: [\"string\", \"false\"], filterConnect: \"or\"}); // [\"c\", \"d\", s2, s1] adam.getFields(obj2, {filter: \"number\", limit: 2}); // [\"b\", \"d\"] adam.getFields(obj2, {filter: {field: \"symbol\"}}) // [s2, s1] adam.getValues(obj); // [1, 2, 3, 4, 5] adam.getValues(obj, {filter: {field: /a|c/}}); // [1, 3] adam.getValueKey(obj, 3); // \"c\" adam.fromArray([{id: \"a\", value: 11}, {id: \"b\", value: 7}, {id: \"c\", value: 10}], \"id\"); // {a: {id: \"a\", value: 11}, b: {id: \"b\", value: 7}, c: {id: \"c\", value: 10}} adam.select([\"negative\", \"odd\"], [null, 4, NaN, 7, false, -2, \"\", 0, -5, 3, null, -9]); // -5 adam.select([\"negative\", \"odd\"], [null, 4, NaN, 8, false, 2, \"\", 0, 30, 4, false], {filterConnect: \"or\"}); // false adam.select([\"negative\", \"odd\"], [null, 4, NaN, 8, false, 2, \"\", 0, 30, 4, false], {filterConnect: \"or\", defaultValue: -3}); // -3 adam.split(obj, [\"a\", \"d\"]); // [{a: 1, d: 4}, {b: 2, c: 3, e: 5}] adam.split(obj, null, {filter: \"odd\"}); // [{a: 1, c: 3, e: 5}, {b: 2, d: 4}] adam.split(obj, null, {filter: [\"even\", /3/], filterConnect: \"or\"}); // [{b: 2, c: 3, d: 4}, {a: 1, e: 5}] adam.remove({a: 1, b: \"2\", c: 3}, \"string\"); // {a: 1, c: 3} adam.remove([1, 2, 3, 4, 5], \"even\"); // [1, 3, 5] adam.empty({x: -1, y: 9}); // {} adam.reverse({a: \"x\", b: \"files\"}); // {x: \"a\", files: \"b\"} adam.reverse(\"eval\"); // \"lave\" adam.transform(\"7.381\", \"integer\"); // 7 adam.copy(obj, {b: \"no\", z: \"a\"}); // {a: 1, b: 2, c: 3, d: 4, e: 5, z: \"a\"} adam.copy(obj, {b: \"no\", z: \"a\"}, {filter: \"odd\"}); // {a: 1, b: \"no\", c: 3, e: 5, z: \"a\"} adam.copy(obj, {b: \"no\", z: \"a\"}, {filter: \"even\", transform: inc}); // {b: 3, d: 5, z: \"a\"} adam.change({a: 1, b: 2, c: 3}, \"reverse\"); // {a: -1, b: -2, c: -3} adam.change({a: 10, b: 28, c: -3, d: null, e: \"zero = 0\"}, \"empty\", {filter: /0/}); // {a: 0, b: 28, c: -3, d: null, e: \"\"} adam.change([1, 2, 3, 4, 5], \"reverse\", {filter: \"even\"}); // [1, -2, 3, -4, 5] adam.map(obj, \"reverse\", {filter: \"odd\"}); // {a: -1, c: -3, e: -5} adam.map([\"1\", \"2\", \"3\"], \"number\"); // [1, 2, 3]See test/adam.js for additional examples. API ↑change(obj: Object, action: Function | String, [settings: Object]): ObjectChange all or filtered fields of object, applying specified action/transformation. checkField(obj: Object, field: String | Symbol, filter: Any, [settings: Object]): BooleanCheck whether the field of given object corresponds to specified condition(s) or filter(s). copy(source: Object, target: Object, [settings: Object]): ObjectCopy all or filtered fields from source object into target object, applying specified transformation if necessary. empty(value: Any): AnyEmpty the given value. fromArray(list: Array, [keyField: Function | String], [settings: Object]): ObjectCreate object (map) from list of objects. getClass(value: Any): StringReturn class of given value (namely value of internal property [[Class]]). getFields(obj: Object, [settings: Object]): ArrayReturn list of all or filtered fields of specified object. getFreeField(obj: Object, [settings: Object]): StringReturn name of first free (absent) field of specified object, that conforms to the following pattern: &lt;prefix&gt;&lt;number&gt; getPropertySymbols(obj: Object): ArrayReturn list of all symbol property keys for given object including keys from prototype chain. This function is defined only when Object.getOwnPropertySymbols is available in JS engine. Otherwise the value of getPropertySymbols field is undefined. getSize(obj: Object, [settings: Object]): IntegerReturn number of all or filtered fields of specified object. getType(value: Any): StringReturn type of given value. getValueKey(obj: Object, value, [all: Boolean]): Array | String | nullReturn the name of field (or list of names) having the specified value in the given object. getValues(obj: Object, [settings: Object]): ArrayReturn list of all or filtered field values of specified object. isEmpty(value: Any): BooleanCheck whether given value is an empty value i.e. null, undefined, 0, empty object, empty array or empty string. isKindOf(value: Any, kind: String): BooleanCheck whether given value has (or does not have) specified kind (type or class). isSizeMore(obj: Object, qty: Number, [settings: Object]): BooleanCheck whether number of all or filtered fields of specified object is more than the given value. map(obj: Object, action: Function | String, [settings: Object]): ObjectCreate new object containing all or filtered fields of the source object/array, applying specified action/transformation for field values. remove(obj: Array | Object, filter: Any, [settings: Object]): Array | ObjectRemove filtered fields/elements from specified object/array. reverse(value: Any): AnyReverse or negate the given value. select(filter: Any, from: Any, [settings: Object]): AnyReturn the value of the first element in the passed array that satisfies the specified filter(s). split(obj: Object, firstObjFields: Array | Object | null, [settings: Object]): ArrayDivide given object into 2 parts: the first part includes specified fields, the second part includes all other fields. transform(value: Any, action: String): AnyTransform the given value applying the specified operation. See doc folder for details. Related projects ↑ eva mixing teo ContributingIn lieu of a formal styleguide, take care to maintain the existing coding style. Add unit tests for any new or changed functionality. Lint and test your code using Grunt. LicenseCopyright (c) 2014-2020 Denis SikulerLicensed under the MIT license. × Search results Close "},"module-adam.html":{"id":"module-adam.html","title":"Module: adam","body":" adam Modules adam Module: adam Functions to create, process and test objects. Source: adam.js, line 10 Methods &lt;static&gt; change(obj, action [, settings]) Change all or filtered fields of object, applying specified action/transformation. Parameters: Name Type Argument Description obj Object Object whose fields should be changed. action function | String An action/operation that should be applied to get new field value. See description of transform setting of copy. settings Object &lt;optional&gt; Operation settings. Keys are settings names, values are corresponding settings values. The following settings are supported: filter - a filter that should be used to select fields for modification (see checkField); fields conforming to the filter will be changed filterConnect: String - a boolean connector that should be used when array of filters is specified in filter setting (see checkField) Source: adam.js, line 994 See: checkField copy Returns: Modified object (value of obj parameter). Type Object &lt;static&gt; checkField(obj, field, filter [, settings]) Check whether the field of given object corresponds to specified condition(s) or filter(s). Parameters: Name Type Argument Description obj Object Object to be processed. field String | Symbol Field that should be checked. filter Any A filter or array of filters specifying conditions that should be checked. A filter can be: a function; if the function returns a true value it means that the field corresponds to this filter; the following parameters will be passed into the function: field value, field name and reference to the object a regular expression; if the field value (converted to string) matches the regular expression it means that the field corresponds to this filter a string; value can be one of the following: own - if the field is own property of the object it means that the field corresponds to this filter !own - if the field is not own property of the object it means that the field corresponds to this filter any other value - is used as the check when calling isKindOf; if isKindOf returns true for the given field value and the filter it means that the field corresponds to this filter an object; if the object has and or or field, its value is used as subfilter and will be passed in recursive call of checkField as value of filter parameter; the field name (and or or) will be used as value of filterConnect setting (see below); if the result of the recursive call is true it means that the field corresponds to this filter if the object has field field, its value is used as filter for the field name (property key) that is being checked; the filter is applied to the field name (property key) in recursive call of checkField as if the key is a tested field value of special object that is created for the check purposes (i.e. checkField({field: field}, \"field\", filter.field, {filterConnect: settings.filterConnect})) if the object has value field, its value is used as filter; if the field value strictly equals to the filter value it means that the field corresponds to this filter in any other case if the field value strictly equals to the object it means that the field corresponds to this filter any other value; if the field value strictly equals to the filter value it means that the field corresponds to this filter settings Object &lt;optional&gt; Operation settings. Keys are settings names, values are corresponding settings values. The following settings are supported (setting's default value is specified in parentheses): filterConnect: String (and) - a boolean connector that should be used when array of filters is specified in filter parameter; valid values are the following: and, or (case-insensitive); any other value is treated as and value: Any - a value that should be used for check instead of field's value Source: adam.js, line 314 See: getClass isKindOf Returns: true if the field corresponds to specified filter(s), otherwise false. Type Boolean &lt;static&gt; copy(source, target [, settings]) Copy all or filtered fields from source object into target object, applying specified transformation if necessary. Parameters: Name Type Argument Description source Object Object whose fields will be copied. target Object Object into which fields should be copied. settings Object &lt;optional&gt; Operation settings. Keys are settings names, values are corresponding settings values. The following settings are supported: filter - a filter that should be used to select fields for copying (see checkField); fields conforming to the filter will be copied filterConnect: String - a boolean connector that should be used when array of filters is specified in filter setting (see checkField) transform - an action/operation that should be applied to get field's value that will be copied instead of value from source object; can be a string specifying transformation (see transform) or a function whose result will be used as field's value; object with the following fields will be passed into the function: field - field name value field value from source object source - reference to the source object target - reference to the target object Source: adam.js, line 945 See: checkField transform Returns: Reference to the target object (value of target parameter). Type Object &lt;static&gt; empty(value) Empty the given value according to the following rules: for array: removes all elements from the value for object: removes all own fields from the value for string: returns empty string for number: returns 0 otherwise: returns undefined Parameters: Name Type Description value Any Value to be processed. Source: adam.js, line 787 Returns: Processed value (for array or object) or empty value corresponding to the given value. Type Any &lt;static&gt; fromArray(list [, keyField] [, settings]) Create object (map) from list of objects. Fields of the created object are values of specified field of objects, values of the created object are corresponding items of the list. Parameters: Name Type Argument Description list Array List of objects/values to be processed. keyField function | String &lt;optional&gt; Specifies names of fields of the created object. Can be name of field or method whose value is used as field name of the created object, or function that returns the field name. In the latter case the following parameters will be passed in the function: the source object (an item of the list), the created object, the index of the source object. When the parameter is not set, items of the list are used as field names. settings Object &lt;optional&gt; Operation settings. Keys are settings names, values are corresponding settings values. The following settings are supported (setting's default value is specified in parentheses): deleteKeyField: Boolean (false) - specifies whether key field (whose value is field name of the created object) should be deleted from the source object (an item of the list) filter - a filter specifying objects that should be included into result (see checkField); an item of the list will be used as value for check filterConnect: String - a boolean connector that should be used when array of filters is specified in filter setting (see checkField) Source: adam.js, line 585 See: checkField Returns: Object created from the given list. Type Object &lt;static&gt; getClass(value) Return class of given value (namely value of internal property [[Class]]). Parameters: Name Type Description value Any Value whose class should be determined. Source: adam.js, line 110 Returns: String indicating value class. Type String &lt;static&gt; getFields(obj [, settings]) Return list of all or filtered fields of specified object. Fields are searched (checked) in the object itself and in its prototype chain. Parameters: Name Type Argument Description obj Object Object to be processed. settings Object &lt;optional&gt; Operation settings. Keys are settings names, values are corresponding settings values. The following settings are supported: filter - a filter specifying fields that should be selected (see checkField) filterConnect: String - a boolean connector that should be used when array of filters is specified in filter setting (see checkField) limit - a maximum number of fields that should be included into result; after the specified number of fields is attained, the search will be stopped Source: adam.js, line 397 See: checkField Returns: List of all or filtered fields of specified object. Type Array &lt;static&gt; getFreeField(obj [, settings]) Return name of first free (absent) field of specified object, that conforms to the following pattern: &lt;prefix&gt;&lt;number&gt; Parameters: Name Type Argument Description obj Object Object in which a free field should be found. If null (or any false value) is set, the first value that conforms to the pattern will be returned. settings Object &lt;optional&gt; Operation settings. Keys are settings names, values are corresponding settings values. The following settings are supported (setting's default value is specified in parentheses): checkPrefix: Boolean (false) - specifies whether pattern consisting only from prefix (without number) should be checked prefix: String (f) - prefix of sought field startNum: Integer (0) - starting number which is used as part of pattern by search/check Source: adam.js, line 528 Returns: Name of field which is absent in the specified object and conforms to the pattern. Type String &lt;static&gt; getPropertySymbols(obj) Return list of all symbol property keys for given object including keys from prototype chain. This function is defined only when Object.getOwnPropertySymbols is available. Parameters: Name Type Description obj Object Object to be processed. Source: adam.js, line 77 Returns: List of all found symbol property keys. Type Array &lt;static&gt; getSize(obj [, settings]) Return number of all or filtered fields of specified object. Parameters: Name Type Argument Description obj Object Object to be processed. settings Object &lt;optional&gt; Operation settings. Keys are settings names, values are corresponding settings values. The following settings are supported: filter - a filter specifying fields that should be counted (see checkField) filterConnect: String - a boolean connector that should be used when array of filters is specified in filter setting (see checkField) Source: adam.js, line 149 See: getFields Returns: Number of all or filtered fields of specified object. Type Integer &lt;static&gt; getType(value) Return type of given value. Parameters: Name Type Description value Any Value whose type should be determined. Source: adam.js, line 124 Returns: For NaN - 'nan', for null - 'null', otherwise - result of typeof operator. Type String &lt;static&gt; getValueKey(obj, value [, bAll]) Return the name of field (or list of names) having the specified value in the given object. Parameters: Name Type Argument Description obj Object Object to be checked. value Any Value that should be searched for. bAll Boolean &lt;optional&gt; Whether names of all found fields having the specified value should be returned. Default value is false. Source: adam.js, line 461 Returns: Names of fields (when bAll is true) or a field name having the specified value, or null when the object do not contain the specified value. Type Array | String | null &lt;static&gt; getValues(obj [, settings]) Return list of all or filtered field values of specified object. Parameters: Name Type Argument Description obj Object Object to be processed. settings Object &lt;optional&gt; Operation settings. Keys are settings names, values are corresponding settings values. The following settings are supported: filter - a filter specifying fields that should be selected (see checkField) filterConnect: String - a boolean connector that should be used when array of filters is specified in filter setting (see checkField) Source: adam.js, line 497 See: checkField Returns: List of all or filtered field values of specified object. Type Array &lt;static&gt; isEmpty(value) Check whether given value is an empty value i.e. null, undefined, 0, empty object, empty array or empty string. Parameters: Name Type Description value Any Value to be checked. Source: adam.js, line 196 See: getClass isSizeMore Returns: true if the value is an empty value, otherwise false. Type Boolean &lt;static&gt; isKindOf(value, sKind) Check whether given value has (or does not have) specified kind (type or class). Parameters: Name Type Description value Any Value to be checked. sKind String Type or class for check. Can be any value that is returned by getType and getClass, or one of the following: empty - check whether the value is empty (see isEmpty) even - check whether the value is an even integer false - check whether the value is a false value infinity - check whether the value is a number representing positive or negative infinity integer - check whether the value is an integer number negative - check whether the value is a negative number numeric - check whether the value is a number or a string that can be converted to number odd - check whether the value is an odd integer positive - check whether the value is a positive number real - check whether the value is a real number true - check whether the value is a true value zero - check whether the value is 0 If exclamation mark (!) is set before the kind, it means that the check should be negated i.e. check whether given value does not have the specified kind. For example, !real means: check whether the value is not a real number. Source: adam.js, line 237 See: getClass getType isEmpty Returns: true if value has the specified kind (or does not have when the check is negated), otherwise false. Type Boolean &lt;static&gt; isSizeMore(obj, nValue [, settings]) Check whether number of all or filtered fields of specified object is more than the given value. Parameters: Name Type Argument Description obj Object Object to be checked. nValue Number Value that should be used for comparison with number of fields. settings Object &lt;optional&gt; Operation settings. Keys are settings names, values are corresponding settings values. The following settings are supported: filter - a filter specifying fields that should be counted (see checkField) filterConnect: String - a boolean connector that should be used when array of filters is specified in filter setting (see checkField) Source: adam.js, line 172 See: getFields Returns: true, when number of all or filtered fields is more than the given value, otherwise false. Type Boolean &lt;static&gt; map(obj, action [, settings]) Create new object containing all or filtered fields of the source object/array, applying specified action/transformation for field values. Parameters: Name Type Argument Description obj Array | Object Array/object whose fields should be copied. action function | String An action/operation that should be applied to get field value that will be saved in created object. See description of transform setting of copy. settings Object &lt;optional&gt; Operation settings. Keys are settings names, values are corresponding settings values. The following settings are supported: filter - a filter that should be used to select fields for copying (see checkField); fields conforming to the filter will be copied in created object filterConnect: String - a boolean connector that should be used when array of filters is specified in filter setting (see checkField) Source: adam.js, line 1026 See: checkField copy Returns: Created object containing processed fields. Type Object &lt;static&gt; remove(obj, filter [, settings]) Remove filtered fields/elements from specified object/array. Parameters: Name Type Argument Description obj Array | Object Array or object to be processed. filter Any A filter or array of filters specifying fields or elements that should be removed (see checkField). settings Object &lt;optional&gt; Operation settings. Keys are settings names, values are corresponding settings values. The following settings are supported: filterConnect: String - a boolean connector that should be used when array of filters is specified in filter parameter (see checkField) Source: adam.js, line 750 See: checkField Returns: Processed array or object. Type Array | Object &lt;static&gt; reverse(value) Reverse or negate the given value according to the following rules: for array: reverses order of its elements for object: swaps fields with their values (i.e. for {a: \"b\", c: \"d\"} returns {b: \"a\", d: \"c\"}) for string: reverses order of its characters for number: returns negated value (i.e. - value) for boolean: returns negated value (i.e. ! value) otherwise: returns source value without modification Parameters: Name Type Description value Any Value to be processed. Source: adam.js, line 828 Returns: Processed value. Type Any &lt;static&gt; select(filter, from [, settings]) Return the value of the first element in the passed array that satisfies the specified filter(s). If value passed for selection is not an array, the value will be returned as is. If no element in the passed array satisfies the specified filter(s), settings.defaultValue or the last element of the array (or undefined when the array is empty) will be returned. Parameters: Name Type Argument Description filter Any Filter that should be used to select a value (see checkField for details). from Any An array from which a value should be selected. If passed value is not an array, the value will be returned as is. settings Object &lt;optional&gt; Operation settings. Keys are settings names, values are corresponding settings values. The following settings are supported (setting's default value is specified in parentheses): defaultValue: Any - default value that should be used when no element in the passed array satisfies the specified filter(s) filterConnect: String (and) - a boolean connector that should be used when array of filters is specified in filter parameter (see checkField for details) Source: adam.js, line 651 See: checkField Returns: The first element in the passed array that satisfies the specified filter(s), or settings.defaultValue or the last element of the array when no element in the array satisfies the specified filter(s), or settings.defaultValue or undefined when the array is empty, or the value of from parameter when passed value is not an array. Type Any &lt;static&gt; split(obj, firstObjFields [, settings]) Divide given object into 2 parts: the first part includes specified fields, the second part includes all other fields. Parameters: Name Type Argument Description obj Object Object to be divided. firstObjFields Array | Object | null List of names of fields that should be included in the first part, or an object defining those fields. If value is not specified (null or undefined), filter setting should be used to divide fields into parts. settings Object &lt;optional&gt; Operation settings. Keys are settings names, values are corresponding settings values. The following settings are supported: filter - a filter that should be used to divide fields into parts (see checkField); fields conforming to the filter will be included in the first part, fields that do not conform to the filter will be included in the second part filterConnect: String - a boolean connector that should be used when array of filters is specified in filter setting (see checkField) Source: adam.js, line 704 See: checkField Returns: Created parts: item with index 0 is the first part, item with index 1 is the second part. Type Array &lt;static&gt; transform(value, sAction) Transform the given value applying the specified operation. Parameters: Name Type Description value Any Value to be transformed. sAction String Operation that should be applied to transform the value. Can be one of the following: array - convert the value to array (using Array(value)) boolean - convert the value to boolean value (using Boolean(value)) empty - empty the value (see empty) function - convert the value to function (using Function(value)) integer - try to convert the value to an integer number (using Math.round(Number(value)) number - try to convert the value to number (using Number(value)) object - convert the value to object (using Object(value)) reverse - reverse the value (see reverse) string - convert the value to string (using String(value)) otherwise - source value Source: adam.js, line 880 See: empty reverse Returns: Transformed value. Type Any × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
